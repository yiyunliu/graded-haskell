embed
{{ coq-preamble
Require Export Metalib.LibLNgen.
Require Export Qual.grade_sig.
Require Export Qual.sort_sig.
}}

metavar tmvar, x, y, z, f, g, n ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

metavar qualityvar, m ::=
  {{ coq atom }}
  {{ com qualities }}
  {{ lex alphanum }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR

grammar

grade, psi {{ tex \ell }} , phi {{ tex k }} :: 'q_' ::=   {{ coq grade }}
  | CTime                         :: M :: C  {{ tex { \color{black}{C} } }} {{ coq q_C }}
  | top                           :: M :: Top {{ tex { \color{black}{\top} } }} {{ coq q_Top }}
  | psi1 \/ psi2                  :: M :: Join {{ tex [[psi1]] \vee [[psi2]] }} {{ coq (q_join [[psi1]] [[psi2]]) }}
  | psi1 /\ psi2                  :: M :: Meet {{ tex [[psi1]] \wedge [[psi2]] }} {{ coq (q_meet [[psi1]] [[psi2]]) }}
  | ( psi )                       :: M :: paren {{ tex [[ psi ]] }}
                                                {{ coq ([[psi]]) }}

sort, s :: '' ::=  {{ coq sort }}
  | star                          :: M :: Star {{ coq star }}


tm, a , b , c , A , B , C, u, v, U, V :: 'a_' ::= {{ com terms and types }}

  | Unit         ::   :: TyUnit  {{ com unit type }}
  | unit         ::   :: TmUnit  {{ com unit term }}

  | Pi x : psi A . B    ::    :: Pi
    (+ bind x in B +)
    {{ tex \Pi [[x]]\!:^{[[psi]]}\![[A]].[[B]] }}
    {{ com dependent function type }}

  | \ psi x : A . a            ::    :: Abs
    (+ bind x in a +)
    {{ tex \lambda^{[[psi]]} [[x]]\!:\![[A]] . [[a]] }}
    {{ com function }}

  | \ x . a    :: :: EAbs
    (+ bind x in a +)
    {{ com erased function }}

  | a b        :: :: EApp
    {{ com erased function application }}

  | a psi b                  ::   :: App
    {{ tex [[a]] \; [[b]]^{[[psi]]} }}
    {{ com function application }}

  | ( A )       :: M  :: Paren {{ coq ([[A]]) }}

  | type s   ::    :: Type {{ tex [[s]] }} {{ com sort }}

  | x           ::    :: Var {{ com variable }}

   %% standard substitution, using open
   | a { b / x }      :: S :: Subst
     {{ coq (open_tm_wrt_tm [[x a]] [[b]]) }}

   %% Ott parsing precedence is hard
   | (# a #)          :: S :: SecretParen
     {{ coq [[a]] }} {{ tex [[a]] }}
     {{ com parsing precedence is hard }}

   | x : psi A && B ::  :: SSigma
     (+ bind x in B +)
     {{ tex ([[x]]\!\!:^{[[psi]]}\!\![[A]]) \, \& \, [[B]] }}
   | ( a psi & b )            ::     :: SPair
     {{ tex ([[a]]^{[[psi]]} \, \& \, [[b]]) }}
   | fst psi a                ::     :: Proj1
%     {{ tex \ottkw{fst}^{[[psi]]}\;[[a]] }}
     {{ tex \pi_1^{[[psi]]}\;[[a]] }}
   | snd psi a                ::     :: Proj2
%     {{ tex \ottkw{snd}^{[[psi]]} [[a]] }}
     {{ tex \pi_2^{[[psi]]} [[a]] }}
   | a & b      :: :: ESPair
   | fst a      :: :: EProj1
   | snd a      :: :: EProj2



substitutions
  single a x     :: subst_tm

freevars
  a x   :: fv_tm


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  This part is not handled by LNgen

grammar


context, W {{ tex \Omega }} :: 'ctx_' ::= {{ com contexts }}
                                          {{ coq list ( atom * (grade * tm) ) }}
   | empty           ::    :: Empty       {{ coq nil }}

   | x : psi A       ::    :: One         {{ coq ([[x]]~([[psi]],[[A]]))}}
                                          {{ tex [[x]]\! :^{[[psi]]}\![[A]] }}
   | W ++ W'         :: M  :: Append      {{ coq ([[W']]++[[W]])}}
                                          {{ tex [[W]], [[W']] }}

   | ( W )           :: M  :: Paren       {{ coq ([[W]]) }}
   | (# W #)         :: M  :: SecretParen {{ coq [[W]]}} {{ tex [[W]]}}
   | W { a / x }     :: M  :: Subst       {{ coq (subst_ctx [[a]][[x]][[W]] }}
%   | phi \/ W        :: M  :: Join_l      {{ coq (join_ctx_l [[phi]] [[W]]) }}
%   | W \/ phi        :: M  :: Join_r      {{ coq (join_ctx_r [[W]] [[phi]]) }}
   | phi /\ W        :: M  :: Meet_l      {{ coq (meet_ctx_l [[phi]] [[W]]) }}
%   | W /\ phi        :: M  :: Meet_r      {{ coq (meet_ctx_r [[W]] [[phi]]) }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Terminals  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

terminals :: 'terminals_' ::=
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | -->               ::   :: step          {{ tex \longrightarrow }}
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall     {{ tex \forall }}
  | in                ::   :: in         {{ tex \ottkw{in} }}
  | let               ::   :: let        {{ tex \ottkw{let} }}
  | bind              ::   :: bind       {{ tex \ottkw{bind} }}
  | notin             ::   :: notin      {{ tex \not\in }}
  | <=                ::   :: check      {{ tex \leq }}
  | =>                ::   :: infer      {{ tex \Rightarrow }}
  | =>*               ::   :: minfer      {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow      {{ tex \to }}
  | <-|               ::   :: mapsfrom   {{ tex \mapsfrom }}
  | []                ::   :: box        {{ tex \Box }}
  | |-                ::   :: entails    {{ tex \vdash }}
  | |-e               ::   :: entailsE   {{ tex \vdash }}
  | |--e              ::   :: entailsEE  {{ tex \vdash }}
  | |-$               ::   :: entailsC   {{ tex \vdash_{C} }}
  | -|                ::   :: produces   {{ tex \dashv }}
  | |=                ::   :: hs_entails {{ tex \vDash }}
  | |==               ::   :: hs_entaill {{ tex \vDash }}
  | /=                ::   :: neq        {{ tex \neq }}
  | |>                ::   :: cast       {{ tex \triangleright }}
  | ok                ::   :: ok         {{ tex \ \mathsf{ok} }}
  | _                 ::   :: blank      {{ tex \_ }}
  | ~>                ::   :: produce    {{ tex \leadsto }}
  | ~>*               ::   :: multistep  {{ tex \leadsto^{\ast} }}
  | ~>h               ::   :: steph      {{ tex \leadsto }}
  | empty             ::   :: empty      {{ tex \varnothing }}
  | hole              ::   :: hole       {{ tex \circ }}
  | fv                ::   :: fv         {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom        {{ tex \mathsf{dom} }}
  | ~                 ::   :: twiddle    {{ tex \sim }}
  | ~~                ::   :: compatible {{ tex \asymp }}
  | '|'               ::   :: bar        {{ tex | }}
  | o                 ::   :: bullet     {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | |=>|              ::   :: erasesto   {{ tex \mathrel{|\Rightarrow|} }}
  | |-=               ::   :: turneq     {{ tex \vdash_{=} }}
  | refl2             ::   :: refl2      {{ tex \mathbf{refl_2}  }}
  | ++                ::   :: concat     {{ tex \mathop{++} }}
  | *                 ::   :: times      {{ tex \cdot }}
  | Box               ::   :: Box        {{ tex \ottkw{Box} }}
  | =beta             ::   :: betaeq     {{ tex =_{\beta} }}
  | ;                 ::   :: semi       {{ tex \mathsf{;} }}
  | Pi                ::   :: Pi         {{ tex \Pi }}
  | inj               ::   :: inj        {{ tex \ottkw{inj} }}
  | case              ::   :: case       {{ tex \ottkw{case} }}
  | /\                ::   :: meet       {{ tex \wedge }}
  | \/                ::   :: join       {{ tex \vee }}
  | |-->              ::   :: ctyp       {{ tex \Vdash }}
  | implies           ::   :: implies    {{ tex \ottkw{implies} }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement

  | x : psi A in W               ::   :: inW
    {{ tex [[x]]\! :^{[[psi]]}\![[A]] \in [[ W ]] }}
    {{ coq binds [[x]] ([[psi]], [[A]]) [[W]] }}
  | x in fv a             ::   :: used
    {{ coq [[x]] `in` fv_tm_tm_tm [[a]] }}
    {{ tex [[x]]\ [[in]]\ [[fv]]\ [[a]] }}
  | x notin fv a             ::   :: fresh
    {{ coq [[x]] `notin` fv_tm_tm_tm [[a]] }}
  | x notin dom W            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[W]]) }}
  | x notin dom D            ::   :: notInDx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[D]]) }}
  | x notin dom H            ::   :: notInHX
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[H]]) }}
    {{ tex [[ x ]] \notin [[ dom ]] \: [[ H ]] }}
  | a = b                    ::   :: equal
    {{ coq [[a]]=[[b]] }}
  | a = psi b                ::   :: equalQ
    {{ tex [[ a ]] =_{[[ psi ]]} [[ b ]] }}

  | W1 = W2                  ::   :: equalctx
    {{ coq ([[W1]] = [[W2]]) }}

  | D1 = D2                  ::   :: equalD
    {{ coq ([[D1]] = [[D2]]) }}

  | psi1 <= psi2              ::   :: subrho
    {{ coq ([[psi1]] <= [[psi2]]) }}
  | psi1 < psi2               ::   :: ltrho
    {{ coq ([[psi1]] < [[psi2]]) }}


  | True                     ::   :: True
    {{ coq True }}
  | False                    ::   :: False
    {{ coq False }}
  | not formula              ::   :: not
    {{ coq not ([[formula]]) }}
    {{ tex \neg [[formula]] }}
  | formula1 /\ formula2     ::   :: and
    {{ coq [[formula1]] /\ [[formula2]] }}
  | formula1 \/ formula2     ::   :: or
    {{ coq [[formula1]] \/ [[formula2]] }}
  | formula1 implies formula2     ::   :: implies
    {{ coq [[formula1]] -> [[formula2]] }}
    {{ tex [[formula1]]\ [[implies]]\ [[formula2]] }}
  | formula1 iff formula2     ::   :: iff
    {{ coq [[formula1]] <-> [[formula2]] }}

  | ( formula )              ::   :: Paren
    {{ coq ([[formula]]) }}

  | uniq W                   ::   :: uniqW
    {{ coq uniq [[W]] }} {{ tex }}

  | [ formula ] ::    :: Suppress
    {{ tex \suppress{[[formula]]} }}
         {{ coq [[formula]] }}

  | nolc A                  :: M :: nolcA
    {{ tex }}
    {{ coq True }}

  | nolc C                  :: M :: nolcC
    {{ tex }}
    {{ coq True }}


  | ctx D W :: M :: ctx
    {{ coq ctx [[D]][[W]] }}
    {{ tex [[D]]\vdash[[W]] }}

  | |- a ~>* b ::  :: multistep

  | W |- a : A :: :: Typ {{ tex [[W]] \vdash[[a]]:[[A]] }}

  | axiom s1 s2 ::  :: axiom
     {{ coq axiom [[s1]] [[s2]] }}
  | rule s1 s2 s3 ::   :: rule
     {{ coq rule [[s1]] [[s2]] [[s3]] }}


embed {{ coq

(* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% *)

Local Open Scope grade_scope.

Definition subst_ctx (a : tm) (x:var) : context -> context :=
  map (fun '(g, A) => (g, (subst_tm_tm a x A))).

Definition join_ctx_l (psi : grade) : context -> context :=
  map (fun '(g, A) => (psi * g, A)).

Definition join_ctx_r (psi : grade) : context -> context :=
  map (fun '(g, A) => (g * psi, A)).

Definition meet_ctx_l (psi : grade) : context -> context :=
  map (fun '(g, A) => (psi + g, A)).

Definition meet_ctx_r (psi : grade) : context -> context :=
  map (fun '(g, A) => (g + psi, A)).


Fixpoint close_tm_wrt_tm_rec (n1 : nat) (x1 : tmvar) (a1 : tm) {struct a1} : tm :=
  match a1 with
    | a_TyUnit => a_TyUnit
    | a_TmUnit => a_TmUnit
    | a_Pi psi1 A1 B1 => a_Pi psi1 (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec (S n1) x1 B1)
    | a_Abs psi1 A1 a2 => a_Abs psi1 (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec (S n1) x1 a2)
    | a_App a2 psi1 b1 => a_App (close_tm_wrt_tm_rec n1 x1 a2) psi1 (close_tm_wrt_tm_rec n1 x1 b1)
    | a_Type s => a_Type s
    | a_Var_f x2 => if (x1 == x2) then (a_Var_b n1) else (a_Var_f x2)
    | a_Var_b n2 => if (lt_ge_dec n2 n1) then (a_Var_b n2) else (a_Var_b (S n2))
    | a_Sum A1 A2 => a_Sum (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec n1 x1 A2)
    | a_SSigma psi1 A1 B1 => a_SSigma psi1 (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec (S n1) x1 B1)
    | a_SPair a2 psi1 b1 => a_SPair (close_tm_wrt_tm_rec n1 x1 a2) psi1 (close_tm_wrt_tm_rec n1 x1 b1)
    | a_Proj1 psi1 a2 => a_Proj1 psi1 (close_tm_wrt_tm_rec n1 x1 a2)
    | a_Proj2 psi1 a2 => a_Proj2 psi1 (close_tm_wrt_tm_rec n1 x1 a2)
  end.

Definition close_tm_wrt_tm x1 a1 := close_tm_wrt_tm_rec 0 x1 a1.

}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Common for the two systems

defns
JOp :: '' ::=

defn

|- a ~> a' ::     :: Step :: 'S_' {{ com small-step }}
 {{ tex [[a]] \leadsto [[a']] }} by

|- a ~> a'
------------------------------- :: AppCong
|- a psi b ~> a' psi b


------------------------------- :: Beta
|- (\ psi x : A. a) psi b   ~>  a { b / x }


 |- a ~> a'
--------------------------------------------------------- :: Proj1Cong
 |- fst psi a ~> fst psi a'


 |- a ~> a'
--------------------------------------------------------- :: Proj2Cong
 |- snd psi a ~> snd psi a'


--------------------------------------------------------- :: Proj1Beta
 |- fst psi (a1 psi & a2) ~> a1

--------------------------------------------------------- :: Proj2Beta
 |- snd psi (a1 psi & a2) ~> a2




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%Dependent Types

defns
  Wsub :: '' ::=

defn
  W1 <= W2  ::   :: ctx_sub :: 'CS_' {{ com Context sub }}
by

----------------- :: Empty
  empty <= empty

  psi1 <= psi2
  W1 <= W2
  x notin dom W1
  x notin dom W2
  nolc A
------------------------------------ :: ConsTm
  W1 ++ x:psi1 A <= W2 ++ x : psi2 A


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
   JUnTyDefEq :: '' ::=

defn
 P |- psi phi a == b :: :: CDefEq :: 'CDefEq_' {{ com UnTyped Definitional Equality }}
 {{ tex [[ P ]] \vdash [[ a ]] \equiv_{[[ psi ]]} [[ b ]]  }}

by
   phi0 <= CTime
   phi0 <= phi
   P |- phi a == b
  --------------------- :: Leq
   P |- phi phi0 a == b

   (not (phi0 <= phi)) \/ (CTime < phi0)
   uniq P
  --------------------- :: Nleq
   P |- phi phi0 a == b


defn
 |- a == b :: :: DefEq :: 'Eq_' {{ com UnTyped Definitional Equality }}
 {{ tex [[ a ]] \equiv_{[[ psi ]]} [[ b ]]  }}

by

|- a
-------------------- :: Refl
|- a == a

|- a == b
|- b == c
--------------------- :: Trans
|- a == c

|- a == b
--------------------- :: Sym
|- b == a

|- a ~> b
--------------------- :: Beta
|- psi a == b

%% functions

|- A1 == A2
|- B1 == B2
------------------------------------------------- :: Pi
|- Pi x :psi0 A1. B1 == Pi x :psi0 A2. B2

|- b1 == b2
------------------------------------- :: Abs
|- \ x . b1 == \ x . b2

|- b1 == b2
|- a1 == a2
-------------------------------- :: App
|- b1 a1 == b2 a2

|- Pi x :psi0 A1. B1 == Pi x :psi0 A2. B2
------------------------------------------- :: PiFst
|- A1 == A2

|- Pi x :psi0 A1. B1 == Pi x :psi0 A2. B2
|- a1 == a2
-------------------------------------------- :: PiSnd
|- B1 {a1 / x} == B2 {a2 / x}

%% strong sigmas

|- A1 == A2
|- B1 == B2
----------------------------------------- :: SSigma
|- x :psi0 A1 && B1 == x :psi0 A2 && B2

|- x :psi0 A1 && B1 == x :psi0 A2 && B2
------------------------------------------ :: SSigmaFst
|- A1 == A2

|- x :psi0 A1 && B1 == x :psi0 A2 && B2
|- a1 == a2
-------------------------------------------- :: SSigmaSnd
|- psi B1 {a1/x} == B2 {a2/x}

% WSigmaSndRel / WSigmaSndIrrel ??

|- a1 == a2
|- b1 == b2
---------------------------------------- :: SPair
|- (a1 psi0 & b1) == (a2 psi0 & b2)

|- a1 == a2
------------------------------------------ :: Proj1
fst psi0 a1 == fst psi0 a2

|- a1 == a2
------------------------------- :: Proj2
|- snd psi0 a1 == snd psi0 a2

%% unit

--------------------------- :: TyUnit
|- Unit == Unit

------------------------- :: TmUnit
|- unit == unit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyping :: '' ::=

defn
  W |-- psi a >> u : A ::  :: Typing :: 'T_' {{ com Typing }}
{{ tex [[W]] \vdash [[a]]:^{[[psi]]} [[A]] }}

 by

uniq W
axiom s1 s2
-------------------------- :: Type
W |-- psi type s1 >> type s1 : type s2

W |-- psi a >> u : A
W |-- top A >> U : type s
W |-- top B >> V : type s
|- U == V
------------------------------- :: Conv
W |-- psi a >> u : B

uniq W
psi0 <= psi
x : psi0 A in W
--------------------------------------------- :: Var
W |-- psi x >> x : A

%% functions

W |-- psi A >> U : type s1
W ++ x : psi A |-- psi B >> V : type s2
rule s1 s2 s3
--------------------------------------- :: Pi
W |-- psi Pi x :psi0 A. B >> Pi x : psi0 U. V : type s3

(CTime /\ W) ++ x : top A |-- CTime b >> v : B
W |-- top (Pi x:top A. B) >> U : type s
----------------------------------------------- :: AbsIrrel
W |-- top \ top x : A . b >> v : Pi x :top A . B

(psi0 <= CTime) \/ (psi <= CTime)
W ++ x : psi0 A |-- psi b >> v : B
W |-- top (Pi x:psi0 A. B) >> U : type s
----------------------------------------------- :: Abs
W |-- psi \ psi0 x : A . b >> \ x . v : Pi x :psi0 A . B


W |-- psi b >> v : Pi x :top A . B
W |-- top a >> u : A
------------------------------------------- :: AppIrrel
W |-- psi b top a >> v : B {a/x}

psi0 <= CTime
W |-- psi b >> v : Pi x :psi0 A . B
W |-- psi0 a >> u : A
------------------------------------------- :: App
W |-- psi b psi0 a >> v u : B {a/x}

%% strong sigmas
%% We don't allow the first component to be I b/c then fst doesn't make sense.

W |-- psi A >> U : type s1
W ++ x : psi A |-- psi B >> V : type s2
rule s1 s2 s3
---------------------------------------- :: SSigma
W |-- psi x :psi0 A && B >> psi0 U && V : type s3

W |-- top x:top A && B >> U : type s
W |-- top a >> u : A
W |-- psi b >> v : B {a/x}
------------------------------------------ :: SPairIrrel
W |-- psi (a top & b) >> v : x :top A && B

psi0 <= CTime
W |-- top x:psi0 A && B >> U : type s
W |-- psi0 a >> u : A
W |-- psi b >> v : B {a/x}
------------------------------------------ :: SPair
W |-- psi (a psi0 & b) >> (u & v) : x :psi0 A && B

%% No SPairI

W |-- psi a : x :psi0 A && B
psi0 <= psi
----------------------------------- :: Proj1
W |-- psi fst psi0 a  : A

W |-- psi a : x :psi0 A && B
----------------------------------- :: Proj2
W |-- psi snd psi0 a : B {fst psi0 a / x}

%% unit

uniq W
-------------------------- :: TmUnit
W |-- psi Unit : type s

uniq W
-------------------------- :: TyUnit
W |-- psi unit : Unit



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
   JCTyping :: '' ::=

defn
W |--> psi a : A ::    :: CTyping :: 'CT_'
{{ tex [[W]][[|-->]] [[a]]:^{[[psi]]} [[A]] }}
by


W |-- psi a : A
psi <= CTime
------------------- :: Leq
W |--> psi a : A

CTime /\ W |-- CTime a : A
CTime < psi
-------------------------- :: Top
W |--> psi a : A


defns
   JCtx :: '' ::=

defn
|- W ::     :: Ctx :: 'Ctx_'
by

------------- :: Empty
|- empty


|- W
CTime /\ W |-- CTime A : type s
x notin dom W
------------------------- :: Cons
|- W ++ x :psi0 A



defns
   JValueType :: '' ::=

defn
ValueType A ::   :: ValueType :: 'ValueType_'
{{ com Types with head forms (erased language) }}
{{ tex \mathsf{ValueType}\ [[A]] }}
by

------- :: Type
ValueType type s


------- :: Unit
ValueType Unit

---------------------------- :: Pi
ValueType Pi x : psi A . B

---------------------------- :: WSigma
ValueType Sigma x : psi A . B

---------------------------  :: SSigma
ValueType x : psi A && B

--------------------------- :: Sum
ValueType A + B

defns
   JConsistent :: '' ::=

defn
   Consistent a b ::  :: Consistent :: 'Consistent_a_'
   {{ com Types do not differ in their heads }}
  {{ tex \suppress{\mathsf{Consistent}\ [[a]] \ [[b]] } }}
by

---------------------- :: Type
Consistent type s type s

---------------------- :: Unit
Consistent Unit Unit

--------------------------------------------------- :: Pi
Consistent (Pi x : psi A . B) (Pi x : psi A'. B')

--------------------------------------------------- :: WSigma
Consistent (Sigma x : psi A . B) (Sigma x : psi A'. B')

--------------------------------------------------- :: SSigma
Consistent (# x : psi A && B #) (# x : psi A' && B' #)

--------------------------------------------------- :: Sum
Consistent (A + B) (A' + B')

not ValueType a
---------------------- :: Step_R
Consistent a b

not ValueType b
---------------------- :: Step_L
Consistent a b

defns
   JPar :: '' ::=

defn
P |- psi psi0 a => b ::  :: CPar :: 'CPar_' {{ com Parallel reduction at [[psi]] is guarded by [[psi0]] }}
 {{ tex [[ P ]] \vdash^{[[psi0]]}_{[[psi]]} [[ a ]] [[=>]] [[ b ]]  }}

by

psi0 <= psi
P |- psi a1 => a2
-------------------------------- :: Leq
P |- psi psi0 a1 => a2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |- psi psi0 a1 => a2


defn
 P |- psi  a => b :: :: Par :: 'Par_' {{ com Parallel Reduction }}
 {{ tex [[P]] [[|-]]  [[ a ]] \Rightarrow_{[[ psi ]]} [[ b ]]  }}
by

P |- psi a
-------------------- :: Refl
P |- psi a => a

P |- psi  A1 => A2
P ++ x : psi |- psi  B1 => B2
---------------------------------------------- :: Pi
P |- psi  Pi x :psi1 A1. B1 => Pi x :psi1 A2. B2

P |- psi  a => (\ psi0 x : A. a')
P |- psi psi0 b => b'
----------------------------- :: AppBeta
P |- psi  a psi0 b => a' { b' / x }

P |- psi a => a'
P |- psi psi0 b => b'
----------------------------- :: App
P |- psi  a psi0 b => a' psi0  b'

P ++ x: psi0 |- psi  b1 => b2
P |- psi top A1 => A2
------------------------------------- :: Abs
P |- psi  \ psi0 x : A1 . b1 => \ psi0 x : A2 . b2

P |- psi  A1 => A2
P ++ x : psi |- psi  B1 => B2
------------------------------------------------ :: WSigma
P |- psi  Sigma x :psi1 A1. B1 => Sigma x :psi1 A2. B2

P |- psi psi0 a1 => a2
P |- psi b1 => b2
----------------------------------------------- :: WPair
P |- psi  (a1 psi0, b1) => (a2 psi0, b2)

P |- psi  a1 => (a1' psi0, a2')
P ++ x : psi0 |- psi  b1 => b2 {x/x}
--------------------------------------------------------------- :: WPairBeta
P |- psi let (x psi0 , ) = a1 in b1 => b2 { a1' / x } bot a2'

P |- psi  a1 => a2
P ++ x : psi0 |- psi  b1 => b2
------------------------------------------------------------------------ :: LetPair
P |- psi  let (x psi0 , ) = a1 in b1 => let (x psi0 , ) = a2 in b2

P |- psi  A1 => A2
P ++ x : psi |- psi  B1 => B2
----------------------------------------- :: SSigma
P |- psi  x :psi1 A1 && B1 => x :psi1 A2 && B2

P |- psi psi0 a1 => a2
P |- psi b1 => b2
---------------------------------------- :: SPair
P |- psi  (a1 psi0 & b1) => (a2 psi0 & b2)

P |- psi  a1 => (a1' psi0 & a2)
psi0 <= psi
------------------------------------------ :: Proj1Beta
P |- psi  fst psi0 a1 => a1'

P |- psi  a1 => a2
psi0 <= psi
------------------------------------------ :: Proj1
P |- psi  fst psi0 a1 => fst psi0 a2

P |- psi  a1 => (a1' psi0 & a2)
------------------------------- :: Proj2Beta
P |- psi  snd psi0 a1 => a2


P |- psi  a1 => a2
------------------------------- :: Proj2
P |- psi  snd psi0 a1 => snd psi0 a2


P |- psi  A1 => A1'
P |- psi  A2 => A2'
--------------------------------------- :: Sum
P |- psi  A1 + A2 => A1' + A2'

P |- psi  a1 => a1'
----------------------------------- :: Inj1
P |- psi  inj1 a1 => inj1 a1'

P |- psi  a2 => a2'
------------------------------------ :: Inj2
P |- psi  inj2 a2 => inj2 a2'

P |- psi a => inj1 a'
P |- psi  b1 => b1'
P |- psi  b2 => b2'
psi0 <= psi
---------------------------------------------------- :: CaseBeta1
P |- psi  case psi0 a of b1; b2 => b1' psi0 a'

P |- psi a => inj2 a'
P |- psi  b1 => b1'
P |- psi  b2 => b2'
psi0 <= psi
---------------------------------------------------- :: CaseBeta2
P |- psi  case psi0 a of b1; b2 => b2' psi0 a'

P |- psi a => a'
P |- psi  b1 => b1'
P |- psi  b2 => b2'
psi0 <= psi
---------------------------------------------------- :: Case
P |- psi  case psi0 a of b1; b2 => case psi0 a' of b1';b2'


defns
   JMultiPar :: '' ::=
defn
P |- psi  a =>* b  ::   :: MultiPar :: 'MP_'
{{ tex [[P]] [[|-]] [[a]] [[=>*]]_{[[psi]]} [[b]] }}
{{ com multistep parallel reduction }}
by

P |- psi a
------------------------- :: Refl
P |- psi a =>* a

P |- psi  a =>  b
P |- psi  b =>*  a'
-------------------------- :: Step
P |- psi  a =>*  a'

defns
   JJoins :: '' ::=
defn
P |- psi  a <=> b  ::   :: Joins :: ''
{{ tex [[P]][[|-]] [[a]] [[<=>]]_{[[psi]]}  [[b]] }}
{{ com parallel reduction to a common term }}
by

P |- psi  a1 =>* b1
P |- psi  a2 =>* b2
P |- psi  b1 ~~ b2
-------------------------- :: join
P |- psi  a1 <=> a2

defns
   JValue :: '' ::=

defn
Value A ::   :: Value :: 'V_'
{{ com Types with head forms (erased language) }}
{{ tex \mathsf{ValueType}\ [[A]] }}
by

ValueType a
------- :: ValueType
Value a


---------- :: TmUnit
Value unit

---------------------------- :: Abs
Value \ psi x : A . a

---------------------------- :: EAbs
Value \x . a

---------------------------- :: WPair
Value ( a psi , b )

---------------------------  :: SPair
Value ( a psi & b )

--------------------------- :: Inj1
Value inj1 a

--------------------------- :: Inj2
Value inj2 a


defns
  JCMultiPar :: '' ::=
defn
P |- psi psi0 a =>* b ::   :: CMultiPar :: 'CMP_'
{{ tex [[P]] [[|-]]_{[[psi]]}^{[[psi0]]} [[a]] [[=>*]] [[b]] }}
{{ com }}

by

psi0 <= psi
P |- psi a1 =>* a2
-------------------------------- :: Leq
P |- psi psi0 a1 =>* a2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |- psi psi0 a1 =>* a2


defns
  JCJoins :: '' ::=
defn
P |- psi psi0 a <=> b ::   :: CJoins :: 'CJ_'
{{ tex [[P]] [[|-]]_{[[psi]]}^{[[psi0]]} [[a]] [[<=>]] [[b]] }}
{{ com }}

by

psi0 <= psi
P |- psi a1 <=> a2
-------------------------------- :: Leq
P |- psi psi0 a1 <=> a2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |- psi psi0 a1 <=> a2




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
