(* generated by Ott 0.32, locally-nameless lngen from: ../Qualitative.ott *)
Require Import Metalib.Metatheory.
Require Export Metalib.LibLNgen. 
Require Export Qual.grade_facts.
Require Export Qual.sort_sig.
From mathcomp Require Import ssreflect ssrbool.
Close Scope bool_scope.

(** syntax *)
Definition tmvar : Set := var. (*r variables *)
Definition qualityvar : Set := atom. (*r qualities *)



Inductive tm : Set :=  (*r terms and types *)
 | a_TyUnit : tm (*r unit type *)
 | a_TmUnit : tm (*r unit term *)
 | a_Pi (psi:grade) (A:tm) (B:tm) (*r dependent function type *)
 | a_Abs (psi:grade) (A:tm) (a:tm) (*r function *)
 | a_App (a:tm) (psi:grade) (b:tm) (*r function application *)
 | a_Type (s:sort) (*r sort *)
 | a_Var_b (_:nat) (*r variable *)
 | a_Var_f (x:tmvar) (*r variable *)
 | a_Sum (A1:tm) (A2:tm) (*r sum type *)
 | a_Inj1 (a:tm) (*r injection into sum type *)
 | a_Inj2 (a:tm) (*r injection into sum type *)
 | a_Case (psi:grade) (a:tm) (b1:tm) (b2:tm) (*r case elimination of sum type *)
 | a_WSigma (psi:grade) (A:tm) (B:tm) (*r dependent tuple type *)
 | a_WPair (a:tm) (psi:grade) (b:tm) (*r tuple creation *)
 | a_LetPair (psi:grade) (a:tm) (b:tm) (*r tuple elimination *)
 | a_SSigma (psi:grade) (A:tm) (B:tm)
 | a_SPair (a:tm) (psi:grade) (b:tm)
 | a_Proj1 (psi:grade) (a:tm)
 | a_Proj2 (psi:grade) (a:tm).

Definition econtext : Set := list ( atom * grade ).

Definition context : Set := list ( atom * (grade * tm) ).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_tm_wrt_tm_rec (k:nat) (a5:tm) (a_6:tm) {struct a_6}: tm :=
  match a_6 with
  | a_TyUnit => a_TyUnit 
  | a_TmUnit => a_TmUnit 
  | (a_Pi psi A B) => a_Pi psi (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 B)
  | (a_Abs psi A a) => a_Abs psi (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 a)
  | (a_App a psi b) => a_App (open_tm_wrt_tm_rec k a5 a) psi (open_tm_wrt_tm_rec k a5 b)
  | (a_Type s) => a_Type s
  | (a_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => a_Var_b nat
        | inleft (right _) => a5
        | inright _ => a_Var_b (nat - 1)
      end
  | (a_Var_f x) => a_Var_f x
  | (a_Sum A1 A2) => a_Sum (open_tm_wrt_tm_rec k a5 A1) (open_tm_wrt_tm_rec k a5 A2)
  | (a_Inj1 a) => a_Inj1 (open_tm_wrt_tm_rec k a5 a)
  | (a_Inj2 a) => a_Inj2 (open_tm_wrt_tm_rec k a5 a)
  | (a_Case psi a b1 b2) => a_Case psi (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b1) (open_tm_wrt_tm_rec k a5 b2)
  | (a_WSigma psi A B) => a_WSigma psi (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 B)
  | (a_WPair a psi b) => a_WPair (open_tm_wrt_tm_rec k a5 a) psi (open_tm_wrt_tm_rec k a5 b)
  | (a_LetPair psi a b) => a_LetPair psi (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec (S k) a5 b)
  | (a_SSigma psi A B) => a_SSigma psi (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 B)
  | (a_SPair a psi b) => a_SPair (open_tm_wrt_tm_rec k a5 a) psi (open_tm_wrt_tm_rec k a5 b)
  | (a_Proj1 psi a) => a_Proj1 psi (open_tm_wrt_tm_rec k a5 a)
  | (a_Proj2 psi a) => a_Proj2 psi (open_tm_wrt_tm_rec k a5 a)
end.

Definition open_tm_wrt_tm a5 a_6 := open_tm_wrt_tm_rec 0 a_6 a5.

(** closing up abstractions *)
Fixpoint close_tm_wrt_tm_rec (k:nat) (a5:var) (a_6:tm) {struct a_6}: tm :=
  match a_6 with
  | a_TyUnit => a_TyUnit 
  | a_TmUnit => a_TmUnit 
  | (a_Pi psi A B) => a_Pi psi (close_tm_wrt_tm_rec k a5 A) (close_tm_wrt_tm_rec (S k) a5 B)
  | (a_Abs psi A a) => a_Abs psi (close_tm_wrt_tm_rec k a5 A) (close_tm_wrt_tm_rec (S k) a5 a)
  | (a_App a psi b) => a_App (close_tm_wrt_tm_rec k a5 a) psi (close_tm_wrt_tm_rec k a5 b)
  | (a_Type s) => a_Type s
  | (a_Var_b nat) => 
       if (lt_dec nat k) 
         then a_Var_b nat
         else a_Var_b (S nat)
  | (a_Var_f x) => if (a5 === x) then (a_Var_b k) else (a_Var_f x)
  | (a_Sum A1 A2) => a_Sum (close_tm_wrt_tm_rec k a5 A1) (close_tm_wrt_tm_rec k a5 A2)
  | (a_Inj1 a) => a_Inj1 (close_tm_wrt_tm_rec k a5 a)
  | (a_Inj2 a) => a_Inj2 (close_tm_wrt_tm_rec k a5 a)
  | (a_Case psi a b1 b2) => a_Case psi (close_tm_wrt_tm_rec k a5 a) (close_tm_wrt_tm_rec k a5 b1) (close_tm_wrt_tm_rec k a5 b2)
  | (a_WSigma psi A B) => a_WSigma psi (close_tm_wrt_tm_rec k a5 A) (close_tm_wrt_tm_rec (S k) a5 B)
  | (a_WPair a psi b) => a_WPair (close_tm_wrt_tm_rec k a5 a) psi (close_tm_wrt_tm_rec k a5 b)
  | (a_LetPair psi a b) => a_LetPair psi (close_tm_wrt_tm_rec k a5 a) (close_tm_wrt_tm_rec (S k) a5 b)
  | (a_SSigma psi A B) => a_SSigma psi (close_tm_wrt_tm_rec k a5 A) (close_tm_wrt_tm_rec (S k) a5 B)
  | (a_SPair a psi b) => a_SPair (close_tm_wrt_tm_rec k a5 a) psi (close_tm_wrt_tm_rec k a5 b)
  | (a_Proj1 psi a) => a_Proj1 psi (close_tm_wrt_tm_rec k a5 a)
  | (a_Proj2 psi a) => a_Proj2 psi (close_tm_wrt_tm_rec k a5 a)
end.

Definition close_tm_wrt_tm a_6 a5 := close_tm_wrt_tm_rec 0 a_6 a5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_tm *)
Inductive lc_tm : tm -> Prop :=    (* defn lc_tm *)
 | lc_a_TyUnit : 
     (lc_tm a_TyUnit)
 | lc_a_TmUnit : 
     (lc_tm a_TmUnit)
 | lc_a_Pi : forall (psi:grade) (A B:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     (lc_tm (a_Pi psi A B))
 | lc_a_Abs : forall (psi:grade) (A a:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     (lc_tm (a_Abs psi A a))
 | lc_a_App : forall (a:tm) (psi:grade) (b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm (a_App a psi b))
 | lc_a_Type : forall (s:sort),
     (lc_tm (a_Type s))
 | lc_a_Var_f : forall (x:tmvar),
     (lc_tm (a_Var_f x))
 | lc_a_Sum : forall (A1 A2:tm),
     (lc_tm A1) ->
     (lc_tm A2) ->
     (lc_tm (a_Sum A1 A2))
 | lc_a_Inj1 : forall (a:tm),
     (lc_tm a) ->
     (lc_tm (a_Inj1 a))
 | lc_a_Inj2 : forall (a:tm),
     (lc_tm a) ->
     (lc_tm (a_Inj2 a))
 | lc_a_Case : forall (psi:grade) (a b1 b2:tm),
     (lc_tm a) ->
     (lc_tm b1) ->
     (lc_tm b2) ->
     (lc_tm (a_Case psi a b1 b2))
 | lc_a_WSigma : forall (psi:grade) (A B:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     (lc_tm (a_WSigma psi A B))
 | lc_a_WPair : forall (a:tm) (psi:grade) (b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm (a_WPair a psi b))
 | lc_a_LetPair : forall (psi:grade) (a b:tm),
     (lc_tm a) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm b (a_Var_f x) )  )  ->
     (lc_tm (a_LetPair psi a b))
 | lc_a_SSigma : forall (psi:grade) (A B:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     (lc_tm (a_SSigma psi A B))
 | lc_a_SPair : forall (a:tm) (psi:grade) (b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm (a_SPair a psi b))
 | lc_a_Proj1 : forall (psi:grade) (a:tm),
     (lc_tm a) ->
     (lc_tm (a_Proj1 psi a))
 | lc_a_Proj2 : forall (psi:grade) (a:tm),
     (lc_tm a) ->
     (lc_tm (a_Proj2 psi a)).
(** free variables *)
Fixpoint fv_tm_tm (a5:tm) : vars :=
  match a5 with
  | a_TyUnit => {}
  | a_TmUnit => {}
  | (a_Pi psi A B) => (fv_tm_tm A) \u (fv_tm_tm B)
  | (a_Abs psi A a) => (fv_tm_tm A) \u (fv_tm_tm a)
  | (a_App a psi b) => (fv_tm_tm a) \u (fv_tm_tm b)
  | (a_Type s) => {}
  | (a_Var_b nat) => {}
  | (a_Var_f x) => {{x}}
  | (a_Sum A1 A2) => (fv_tm_tm A1) \u (fv_tm_tm A2)
  | (a_Inj1 a) => (fv_tm_tm a)
  | (a_Inj2 a) => (fv_tm_tm a)
  | (a_Case psi a b1 b2) => (fv_tm_tm a) \u (fv_tm_tm b1) \u (fv_tm_tm b2)
  | (a_WSigma psi A B) => (fv_tm_tm A) \u (fv_tm_tm B)
  | (a_WPair a psi b) => (fv_tm_tm a) \u (fv_tm_tm b)
  | (a_LetPair psi a b) => (fv_tm_tm a) \u (fv_tm_tm b)
  | (a_SSigma psi A B) => (fv_tm_tm A) \u (fv_tm_tm B)
  | (a_SPair a psi b) => (fv_tm_tm a) \u (fv_tm_tm b)
  | (a_Proj1 psi a) => (fv_tm_tm a)
  | (a_Proj2 psi a) => (fv_tm_tm a)
end.

(** substitutions *)
Fixpoint subst_tm_tm (a5:tm) (x5:tmvar) (a_6:tm) {struct a_6} : tm :=
  match a_6 with
  | a_TyUnit => a_TyUnit 
  | a_TmUnit => a_TmUnit 
  | (a_Pi psi A B) => a_Pi psi (subst_tm_tm a5 x5 A) (subst_tm_tm a5 x5 B)
  | (a_Abs psi A a) => a_Abs psi (subst_tm_tm a5 x5 A) (subst_tm_tm a5 x5 a)
  | (a_App a psi b) => a_App (subst_tm_tm a5 x5 a) psi (subst_tm_tm a5 x5 b)
  | (a_Type s) => a_Type s
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => (if eq_var x x5 then a5 else (a_Var_f x))
  | (a_Sum A1 A2) => a_Sum (subst_tm_tm a5 x5 A1) (subst_tm_tm a5 x5 A2)
  | (a_Inj1 a) => a_Inj1 (subst_tm_tm a5 x5 a)
  | (a_Inj2 a) => a_Inj2 (subst_tm_tm a5 x5 a)
  | (a_Case psi a b1 b2) => a_Case psi (subst_tm_tm a5 x5 a) (subst_tm_tm a5 x5 b1) (subst_tm_tm a5 x5 b2)
  | (a_WSigma psi A B) => a_WSigma psi (subst_tm_tm a5 x5 A) (subst_tm_tm a5 x5 B)
  | (a_WPair a psi b) => a_WPair (subst_tm_tm a5 x5 a) psi (subst_tm_tm a5 x5 b)
  | (a_LetPair psi a b) => a_LetPair psi (subst_tm_tm a5 x5 a) (subst_tm_tm a5 x5 b)
  | (a_SSigma psi A B) => a_SSigma psi (subst_tm_tm a5 x5 A) (subst_tm_tm a5 x5 B)
  | (a_SPair a psi b) => a_SPair (subst_tm_tm a5 x5 a) psi (subst_tm_tm a5 x5 b)
  | (a_Proj1 psi a) => a_Proj1 psi (subst_tm_tm a5 x5 a)
  | (a_Proj2 psi a) => a_Proj2 psi (subst_tm_tm a5 x5 a)
end.



(* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% *)

Local Open Scope grade_scope.

Definition labels : context -> econtext :=
  map (fun '(u , s) => u).

Definition subst_ctx (a : tm) (x:var) : context -> context :=
  map (fun '(g, A) => (g, (subst_tm_tm a x A))).

Definition squash_ctx (ψ : grade) : context -> context :=    
  map (fun '(ψ0, A) => (ψ ⤓ ψ0, A)).



(** definitions *)

(* defns JOp *)
Inductive Step : tm -> tm -> Prop :=    (* defn Step *)
 | S_AppCong : forall (a:tm) (psi:grade) (b a':tm),
     lc_tm b ->
     Step a a' ->
     Step (a_App a psi b) (a_App a' psi b)
 | S_Beta : forall (psi:grade) (A a b:tm),
     lc_tm A ->
     lc_tm (a_Abs psi A a) ->
     lc_tm b ->
     Step (a_App  ( (a_Abs psi A a) )  psi b)  (open_tm_wrt_tm  a   b ) 
 | S_CaseCong : forall (psi:grade) (a b1 b2 a':tm),
     lc_tm b1 ->
     lc_tm b2 ->
     Step a a' ->
     Step (a_Case psi a b1 b2) (a_Case psi a' b1 b2)
 | S_Case1Beta : forall (psi:grade) (a b1 b2:tm),
     lc_tm b2 ->
     lc_tm b1 ->
     lc_tm a ->
     Step (a_Case psi  ( (a_Inj1 a) )  b1 b2) (a_App b1 psi a)
 | S_Case2Beta : forall (psi:grade) (a b1 b2:tm),
     lc_tm b1 ->
     lc_tm b2 ->
     lc_tm a ->
     Step (a_Case psi  ( (a_Inj2 a) )  b1 b2) (a_App b2 psi a)
 | S_Proj1Cong : forall (psi:grade) (a a':tm),
     Step a a' ->
     Step (a_Proj1 psi a) (a_Proj1 psi a')
 | S_Proj2Cong : forall (psi:grade) (a a':tm),
     Step a a' ->
     Step (a_Proj2 psi a) (a_Proj2 psi a')
 | S_Proj1Beta : forall (psi:grade) (a1 a2:tm),
     lc_tm a2 ->
     lc_tm a1 ->
     Step (a_Proj1 psi (a_SPair a1 psi a2)) a1
 | S_Proj2Beta : forall (psi:grade) (a1 a2:tm),
     lc_tm a1 ->
     lc_tm a2 ->
     Step (a_Proj2 psi (a_SPair a1 psi a2)) a2
 | S_LetPairCong : forall (psi:grade) (a b a':tm),
     lc_tm (a_LetPair psi a b) ->
     Step a a' ->
     Step (a_LetPair psi a b) (a_LetPair psi a' b)
 | S_LetPairBeta : forall (psi:grade) (a1 a2 b:tm),
     lc_tm (a_LetPair psi (a_WPair a1 psi a2) b) ->
     lc_tm a1 ->
     lc_tm a2 ->
     Step (a_LetPair psi (a_WPair a1 psi a2) b) (a_App  (open_tm_wrt_tm  b   a1 )   ⊥  a2).

(* defns Jsub *)
Inductive P_sub : econtext -> econtext -> Prop :=    (* defn P_sub *)
 | P_Empty : 
     P_sub  nil   nil 
 | P_Cons : forall (P1:econtext) (x:tmvar) (psi1:grade) (P2:econtext) (psi2:grade),
      ( psi1  ≤  psi2 )  ->
     P_sub P1 P2 ->
      ~ AtomSetImpl.In  x  (dom  P1 )  ->
      ~ AtomSetImpl.In  x  (dom  P2 )  ->
     P_sub  (  ( x ~ psi1 )  ++ P1 )   (  ( x ~ psi2 )  ++ P2 ) .

(* defns Wsub *)
Inductive ctx_sub : context -> context -> Prop :=    (* defn ctx_sub *)
 | CS_Empty : 
     ctx_sub  nil   nil 
 | CS_ConsTm : forall (W1:context) (x:tmvar) (psi1:grade) (A:tm) (W2:context) (psi2:grade),
      ( psi1  ≤  psi2 )  ->
     ctx_sub W1 W2 ->
      ~ AtomSetImpl.In  x  (dom  W1 )  ->
      ~ AtomSetImpl.In  x  (dom  W2 )  ->
      True  ->
     ctx_sub  (  ( x ~( psi1 , A ))  ++ W1 )   (  ( x ~( psi2 , A ))  ++ W2 ) .

(* defns JTyping *)
Inductive Typing : context -> grade -> tm -> tm -> Prop :=    (* defn Typing *)
 | T_Type : forall (W:context) (psi:grade) (s1 s2:sort),
      uniq  W  ->
      axiom  s1   s2  ->
     Typing W psi (a_Type s1) (a_Type s2)
 | T_Conv : forall (W:context) (psi:grade) (a B A:tm) (psi0:grade) (s:sort),
     Typing W psi a A ->
     Typing  (squash_ctx   ⊤    W )  psi0 B (a_Type s) ->
     Typing W psi a B
 | T_Var : forall (W:context) (psi:grade) (x:tmvar) (A:tm) (psi0:grade),
      uniq  W  ->
      ( psi0  ≤  psi )  ->
      binds  x  ( psi0 ,  A )  W  ->
     Typing W psi (a_Var_f x) A
 | T_Pi : forall (L:vars) (W:context) (psi psi0:grade) (A B:tm) (s3 s1 s2:sort),
     Typing W psi A (a_Type s1) ->
      ( forall x , x \notin  L  -> Typing  (  ( x ~( psi , A ))  ++ W )  psi  ( open_tm_wrt_tm B (a_Var_f x) )  (a_Type s2) )  ->
      rule_pi  s1   s2   s3  ->
     Typing W psi (a_Pi psi0 A B) (a_Type s3)
 | T_Abs : forall (L:vars) (W:context) (psi psi0:grade) (A b B:tm) (psi1:grade) (s:sort),
      ( forall x , x \notin  L  -> Typing  (  ( x ~( psi0 , A ))  ++ W )  psi  ( open_tm_wrt_tm b (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     Typing  (squash_ctx   ⊤    W )  psi1  ( (a_Pi psi0 A B) )  (a_Type s) ->
     Typing W psi (a_Abs psi0 A b) (a_Pi psi0 A B)
 | T_App : forall (W:context) (psi:grade) (b:tm) (psi0:grade) (a B A:tm),
     Typing W psi b (a_Pi psi0 A B) ->
     Typing  (squash_ctx  psi0   W )  psi0 a A ->
     Typing W psi (a_App b psi0 a)  (open_tm_wrt_tm  B   a ) 
 | T_TmUnit : forall (W:context) (psi:grade) (s:sort),
      uniq  W  ->
     Typing W psi a_TyUnit (a_Type s)
 | T_TyUnit : forall (W:context) (psi:grade),
      uniq  W  ->
     Typing W psi a_TmUnit a_TyUnit.

(* defns JCtx *)
Inductive Ctx : context -> Prop :=    (* defn Ctx *)
 | Ctx_Empty : 
     Ctx  nil 
 | Ctx_Cons : forall (W:context) (x:tmvar) (psi0:grade) (A:tm) (psi:grade) (s:sort),
     Ctx W ->
     Typing  (squash_ctx   ⊤    W )  psi A (a_Type s) ->
      ~ AtomSetImpl.In  x  (dom  W )  ->
     Ctx  (  ( x ~( psi0 , A ))  ++ W ) .

(* defns JValueType *)
Inductive ValueType : tm -> Prop :=    (* defn ValueType *)
 | ValueType_Type : forall (s:sort),
     ValueType (a_Type s)
 | ValueType_Unit : 
     ValueType a_TyUnit
 | ValueType_Pi : forall (psi:grade) (A B:tm),
     lc_tm A ->
     lc_tm (a_Pi psi A B) ->
     ValueType (a_Pi psi A B)
 | ValueType_WSigma : forall (psi:grade) (A B:tm),
     lc_tm A ->
     lc_tm (a_WSigma psi A B) ->
     ValueType (a_WSigma psi A B)
 | ValueType_SSigma : forall (psi:grade) (A B:tm),
     lc_tm A ->
     lc_tm (a_SSigma psi A B) ->
     ValueType (a_SSigma psi A B)
 | ValueType_Sum : forall (A B:tm),
     lc_tm A ->
     lc_tm B ->
     ValueType (a_Sum A B).

(* defns JConsistent *)
Inductive Consistent : tm -> tm -> Prop :=    (* defn Consistent *)
 | Consistent_a_Type : forall (s:sort),
     Consistent (a_Type s) (a_Type s)
 | Consistent_a_Unit : 
     Consistent a_TyUnit a_TyUnit
 | Consistent_a_Pi : forall (psi:grade) (A B A' B':tm),
     lc_tm A ->
     lc_tm (a_Pi psi A B) ->
     lc_tm A' ->
     lc_tm (a_Pi psi A' B') ->
     Consistent  ( (a_Pi psi A B) )   ( (a_Pi psi A' B') ) 
 | Consistent_a_WSigma : forall (psi:grade) (A B A' B':tm),
     lc_tm A ->
     lc_tm (a_WSigma psi A B) ->
     lc_tm A' ->
     lc_tm (a_WSigma psi A' B') ->
     Consistent  ( (a_WSigma psi A B) )   ( (a_WSigma psi A' B') ) 
 | Consistent_a_SSigma : forall (psi:grade) (A B A' B':tm),
     lc_tm A ->
     lc_tm (a_SSigma psi A B) ->
     lc_tm A' ->
     lc_tm (a_SSigma psi A' B') ->
     Consistent  (a_SSigma psi A B)   (a_SSigma psi A' B') 
 | Consistent_a_Sum : forall (A B A' B':tm),
     lc_tm A ->
     lc_tm B ->
     lc_tm A' ->
     lc_tm B' ->
     Consistent  ( (a_Sum A B) )   ( (a_Sum A' B') ) 
 | Consistent_a_Step_R : forall (a b:tm),
     lc_tm b ->
      not ( ValueType a )  ->
     Consistent a b
 | Consistent_a_Step_L : forall (a b:tm),
     lc_tm a ->
      not ( ValueType b )  ->
     Consistent a b.

(* defns JPar *)
Inductive CPar : econtext -> grade -> grade -> tm -> tm -> Prop :=    (* defn CPar *)
 | CPar_Leq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
      ( psi0  ≤  psi )  ->
     Par P psi a1 a2 ->
     CPar P psi psi0 a1 a2
 | CPar_Nleq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
     lc_tm a1 ->
     lc_tm a2 ->
      not (  (  ( psi0  ≤  psi )  )  )  ->
      uniq  P  ->
     CPar P psi psi0 a1 a2
with Par : econtext -> grade -> tm -> tm -> Prop :=    (* defn Par *)
 | Par_Pi : forall (L:vars) (P:econtext) (psi psi1:grade) (A1 B1 A2 B2:tm),
     Par P psi A1 A2 ->
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi )  ++ P )  psi  ( open_tm_wrt_tm B1 (a_Var_f x) )   ( open_tm_wrt_tm B2 (a_Var_f x) )  )  ->
     Par P psi (a_Pi psi1 A1 B1) (a_Pi psi1 A2 B2)
 | Par_AppBeta : forall (P:econtext) (psi:grade) (a:tm) (psi0:grade) (b a' b' A:tm),
     Par P psi a  ( (a_Abs psi0 A a') )  ->
     CPar P psi psi0 b b' ->
     Par P psi (a_App a psi0 b)  (open_tm_wrt_tm  a'   b' ) 
 | Par_App : forall (P:econtext) (psi:grade) (a:tm) (psi0:grade) (b a' b':tm),
     Par P psi a a' ->
     CPar P psi psi0 b b' ->
     Par P psi (a_App a psi0 b) (a_App a' psi0 b')
 | Par_Abs : forall (L:vars) (P:econtext) (psi psi0:grade) (A1 b1 A2 b2:tm),
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi0 )  ++ P )  psi  ( open_tm_wrt_tm b1 (a_Var_f x) )   ( open_tm_wrt_tm b2 (a_Var_f x) )  )  ->
     CPar P psi  ⊤  A1 A2 ->
     Par P psi (a_Abs psi0 A1 b1) (a_Abs psi0 A2 b2)
 | Par_WSigma : forall (L:vars) (P:econtext) (psi psi1:grade) (A1 B1 A2 B2:tm),
     Par P psi A1 A2 ->
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi )  ++ P )  psi  ( open_tm_wrt_tm B1 (a_Var_f x) )   ( open_tm_wrt_tm B2 (a_Var_f x) )  )  ->
     Par P psi (a_WSigma psi1 A1 B1) (a_WSigma psi1 A2 B2)
 | Par_WPair : forall (P:econtext) (psi:grade) (a1:tm) (psi0:grade) (b1 a2 b2:tm),
     CPar P psi psi0 a1 a2 ->
     Par P psi b1 b2 ->
     Par P psi (a_WPair a1 psi0 b1) (a_WPair a2 psi0 b2)
 | Par_WPairBeta : forall (L:vars) (P:econtext) (psi psi0:grade) (a1 b1 b2 a1' a2':tm),
     Par P psi a1 (a_WPair a1' psi0 a2') ->
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi0 )  ++ P )  psi  ( open_tm_wrt_tm b1 (a_Var_f x) )   (open_tm_wrt_tm  b2   (a_Var_f x) )  )  ->
     Par P psi (a_LetPair psi0 a1 b1) (a_App  (open_tm_wrt_tm  b2   a1' )   ⊥  a2')
 | Par_LetPair : forall (L:vars) (P:econtext) (psi psi0:grade) (a1 b1 a2 b2:tm),
     Par P psi a1 a2 ->
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi0 )  ++ P )  psi  ( open_tm_wrt_tm b1 (a_Var_f x) )   ( open_tm_wrt_tm b2 (a_Var_f x) )  )  ->
     Par P psi (a_LetPair psi0 a1 b1) (a_LetPair psi0 a2 b2)
 | Par_SSigma : forall (L:vars) (P:econtext) (psi psi1:grade) (A1 B1 A2 B2:tm),
     Par P psi A1 A2 ->
      ( forall x , x \notin  L  -> Par  (  ( x ~ psi )  ++ P )  psi  ( open_tm_wrt_tm B1 (a_Var_f x) )   ( open_tm_wrt_tm B2 (a_Var_f x) )  )  ->
     Par P psi (a_SSigma psi1 A1 B1) (a_SSigma psi1 A2 B2)
 | Par_SPair : forall (P:econtext) (psi:grade) (a1:tm) (psi0:grade) (b1 a2 b2:tm),
     CPar P psi psi0 a1 a2 ->
     Par P psi b1 b2 ->
     Par P psi (a_SPair a1 psi0 b1) (a_SPair a2 psi0 b2)
 | Par_Proj1Beta : forall (P:econtext) (psi psi0:grade) (a1 a1' a2:tm),
     Par P psi a1 (a_SPair a1' psi0 a2) ->
      ( psi0  ≤  psi )  ->
     Par P psi (a_Proj1 psi0 a1) a1'
 | Par_Proj1 : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
     Par P psi a1 a2 ->
      ( psi0  ≤  psi )  ->
     Par P psi (a_Proj1 psi0 a1) (a_Proj1 psi0 a2)
 | Par_Proj2Beta : forall (P:econtext) (psi psi0:grade) (a1 a2 a1':tm),
     Par P psi a1 (a_SPair a1' psi0 a2) ->
     Par P psi (a_Proj2 psi0 a1) a2
 | Par_Proj2 : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
     Par P psi a1 a2 ->
     Par P psi (a_Proj2 psi0 a1) (a_Proj2 psi0 a2)
 | Par_Sum : forall (P:econtext) (psi:grade) (A1 A2 A1' A2':tm),
     Par P psi A1 A1' ->
     Par P psi A2 A2' ->
     Par P psi (a_Sum A1 A2) (a_Sum A1' A2')
 | Par_Inj1 : forall (P:econtext) (psi:grade) (a1 a1':tm),
     Par P psi a1 a1' ->
     Par P psi (a_Inj1 a1) (a_Inj1 a1')
 | Par_Inj2 : forall (P:econtext) (psi:grade) (a2 a2':tm),
     Par P psi a2 a2' ->
     Par P psi (a_Inj2 a2) (a_Inj2 a2')
 | Par_CaseBeta1 : forall (P:econtext) (psi psi0:grade) (a b1 b2 b1' a' b2':tm),
     Par P psi a (a_Inj1 a') ->
     Par P psi b1 b1' ->
     Par P psi b2 b2' ->
      ( psi0  ≤  psi )  ->
     Par P psi (a_Case psi0 a b1 b2) (a_App b1' psi0 a')
 | Par_CaseBeta2 : forall (P:econtext) (psi psi0:grade) (a b1 b2 b2' a' b1':tm),
     Par P psi a (a_Inj2 a') ->
     Par P psi b1 b1' ->
     Par P psi b2 b2' ->
      ( psi0  ≤  psi )  ->
     Par P psi (a_Case psi0 a b1 b2) (a_App b2' psi0 a')
 | Par_Case : forall (P:econtext) (psi psi0:grade) (a b1 b2 a' b1' b2':tm),
     Par P psi a a' ->
     Par P psi b1 b1' ->
     Par P psi b2 b2' ->
      ( psi0  ≤  psi )  ->
     Par P psi (a_Case psi0 a b1 b2) (a_Case psi0 a' b1' b2').

(* defns JMultiPar *)
Inductive MultiPar : econtext -> grade -> tm -> tm -> Prop :=    (* defn MultiPar *)
 | MP_Refl : forall (P:econtext) (psi:grade) (a:tm),
     lc_tm a ->
     MultiPar P psi a a
 | MP_Step : forall (P:econtext) (psi:grade) (a a' b:tm),
     Par P psi a b ->
     MultiPar P psi b a' ->
     MultiPar P psi a a'.

(* defns JJoins *)
Inductive Joins : econtext -> grade -> tm -> tm -> Prop :=    (* defn Joins *)
 | join : forall (P:econtext) (psi:grade) (a1 a2 b1 b2:tm),
     MultiPar P psi a1 b1 ->
     MultiPar P psi a2 b2 ->
     Joins P psi a1 a2.

(* defns JValue *)
Inductive Value : tm -> Prop :=    (* defn Value *)
 | V_ValueType : forall (a:tm),
     ValueType a ->
     Value a
 | V_TmUnit : 
     Value a_TmUnit
 | V_Abs : forall (psi:grade) (A a:tm),
     lc_tm A ->
     lc_tm (a_Abs psi A a) ->
     Value (a_Abs psi A a)
 | V_WPair : forall (a:tm) (psi:grade) (b:tm),
     lc_tm a ->
     lc_tm b ->
     Value (a_WPair a psi b)
 | V_SPair : forall (a:tm) (psi:grade) (b:tm),
     lc_tm a ->
     lc_tm b ->
     Value (a_SPair a psi b)
 | V_Inj1 : forall (a:tm),
     lc_tm a ->
     Value (a_Inj1 a)
 | V_Inj2 : forall (a:tm),
     lc_tm a ->
     Value (a_Inj2 a).

(* defns JCMultiPar *)
Inductive CMultiPar : econtext -> grade -> grade -> tm -> tm -> Prop :=    (* defn CMultiPar *)
 | CMP_Leq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
      ( psi0  ≤  psi )  ->
     MultiPar P psi a1 a2 ->
     CMultiPar P psi psi0 a1 a2
 | CMP_Nleq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
     lc_tm a1 ->
     lc_tm a2 ->
      not (  (  ( psi0  ≤  psi )  )  )  ->
      uniq  P  ->
     CMultiPar P psi psi0 a1 a2.

(* defns JCJoins *)
Inductive CJoins : econtext -> grade -> grade -> tm -> tm -> Prop :=    (* defn CJoins *)
 | CJ_Leq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
      ( psi0  ≤  psi )  ->
     Joins P psi a1 a2 ->
     CJoins P psi psi0 a1 a2
 | CJ_Nleq : forall (P:econtext) (psi psi0:grade) (a1 a2:tm),
     lc_tm a1 ->
     lc_tm a2 ->
      not (  (  ( psi0  ≤  psi )  )  )  ->
      uniq  P  ->
     CJoins P psi psi0 a1 a2.


(** infrastructure *)
#[export] Hint Constructors Step P_sub ctx_sub Typing Ctx ValueType Consistent CPar Par MultiPar Joins Value CMultiPar CJoins lc_tm : core.


